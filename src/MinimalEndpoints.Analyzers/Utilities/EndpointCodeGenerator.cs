using System.Collections.Immutable;
using MinimalEndpoints.Analyzers.Models;
using SymbolDisplayFormat = Microsoft.CodeAnalysis.SymbolDisplayFormat;

namespace MinimalEndpoints.Analyzers.Utilities;

internal static class EndpointCodeGenerator
{
    public static CSharpFileScope GenerateCode(string namespaceName, string className,
        ImmutableArray<EndpointDefinition> endpoints)
    {
        if (endpoints.IsEmpty)
        {
            return null;
        }

        var fileScope = CreateFileScope(namespaceName, className)
            .AddMinimalEndpointsRegistrationMethod(endpoints);

        foreach (var endpoint in endpoints)
        {
            fileScope.AddMinimalEndpointMapMethod(endpoint);
        }

        fileScope.AddMinimalEndpointsMapAllMethods(endpoints);

        return fileScope;
    }

    public static CSharpFileScope CreateFileScope(string namespaceName, string className)
    {
        return new CSharpFileScope("public static", namespaceName, className)
            .WithHeader("""
                        //----------------------
                        // <auto-generated>
                        //     This file was generated by MinimalEndpoints.Analyzers.EndpointGenerator.
                        //     Do not edit this file manually.
                        // </auto-generated>
                        //----------------------
                        #nullable enable
                        """
            )
            .AddUsing("System")
            .AddUsing("System.Threading")
            .AddUsing("System.Threading.Tasks")
            .AddUsing("System.Collections.Generic")
            .AddUsing("System.CodeDom.Compiler")
            .AddUsing("Microsoft.AspNetCore.Builder")
            .AddUsing("Microsoft.AspNetCore.Routing")
            .AddUsing("Microsoft.AspNetCore.Http")
            .AddUsing("Microsoft.Extensions.DependencyInjection")
            .AddUsing("Microsoft.AspNetCore.Mvc")
            .AddUsing("MinimalEndpoints")
            .AddClassAttribute("[GeneratedCode(\"MinimalEndpoints.Analyzers.EndpointGenerator\", \"1.0.0\")]");
    }

    public static CSharpFileScope AddMinimalEndpointsRegistrationMethod(this CSharpFileScope fileScope,
        ImmutableArray<EndpointDefinition> endpoints)
    {
        if (endpoints.IsEmpty)
        {
            return fileScope;
        }

        var method = fileScope.AddMethod(
            modifiers: "public static",
            returnType: "IServiceCollection",
            methodName: "AddMinimalEndpoints",
            parameters: "this IServiceCollection services"
        );

        var usings = fileScope.GetAvailableUsings();

        foreach (var endpoint in endpoints)
        {
            var lifetime = GetLifetimeMethodName(endpoint.MapMethodsAttribute.Lifetime);
            var classTypeName = endpoint.ClassType.ToDisplayString(usings);

            var registrationLine = endpoint.MapMethodsAttribute.ServiceName != null
                ? $"services.{lifetime}<{endpoint.MapMethodsAttribute.ServiceName}, {classTypeName}>();"
                : $"services.{lifetime}<{classTypeName}>();";

            method.AddLine(registrationLine);
        }

        method.AddLine("return services;");

        return fileScope;
    }

    public static CSharpFileScope AddMinimalEndpointMapMethod(this CSharpFileScope fileScope,
        EndpointDefinition endpoint)
    {
        const string instanceParameterBaseName = "endpointInstance";
        var method = fileScope.AddMethod(
            modifiers: "public static",
            returnType: "IEndpointRouteBuilder",
            methodName: endpoint.MappingEndpointMethodName,
            parameters: "this IEndpointRouteBuilder builder, IApplicationBuilder app"
        );

        var usings = fileScope.GetAvailableUsings();
        var classTypeName = endpoint.ClassType.ToDisplayString(usings);
        var serviceName = endpoint.MapMethodsAttribute.ServiceName ?? classTypeName;
        var parameterList = BuildParameterList(endpoint, usings);
        var methodArguments = endpoint.EntryPoint.Parameters.Count > 0
            ? string.Join(", ", endpoint.EntryPoint.Parameters.Select(p => p.Key))
            : "";


        var instanceParameterName = "endpointInstance";
        var index = 0;

        while (endpoint.EntryPoint.Parameters.ContainsKey(instanceParameterName))
        {
            instanceParameterName = GetUniqueIndexedName(instanceParameterBaseName, ++index);
        }

        parameterList.Insert(0, $"[FromServices]{serviceName} {instanceParameterName}");

        var returnTypeName = endpoint.EntryPoint.ReturnType.ToDisplayString(usings);
        method.AddLine(
            $"static {returnTypeName} Handler({string.Join(", ", parameterList)})"
        );
        method.AddLine("{");
        method.AddLine($"return {instanceParameterName}.{endpoint.EntryPoint.Name}({methodArguments});",
            additionalIndentation: 1);
        method.AddLine("}");

        method.AddEmptyLine();

        var pattern = endpoint.MapMethodsAttribute.Pattern;

        if (endpoint.MapMethodsAttribute.Methods.Length > 1)
        {
            var methods = string.Join(", ",
                endpoint.MapMethodsAttribute.Methods.Select(m => $"\"{m.ToUpperInvariant()}\""));
            method.AddLine(
                $"var endpoint = builder.MapMethods(\"{pattern}\", [{methods}], Handler);");
        }
        else
        {
            method.AddLine(
                $"var endpoint = builder.{endpoint.MapMethodsAttribute.EndpointBuilderMethodName}(\"{pattern}\", Handler);");
        }

        if (endpoint.IsConfigurable)
        {
            method.AddLine($"{classTypeName}.Configure(app, endpoint);");
        }

        method.AddLine("return builder;");

        return fileScope;
    }

    private static string GetUniqueIndexedName(string name, int index)
    {
        return index <= 0 ? name : $"{name}{index}";
    }

    public static void AddMinimalEndpointsMapAllMethods(this CSharpFileScope fileScope,
        ImmutableArray<EndpointDefinition> endpoints)
    {
        var method = fileScope.AddMethod(
            modifiers: "public static",
            returnType: "IApplicationBuilder",
            methodName: "UseMinimalEndpoints",
            parameters: "this IApplicationBuilder app"
        );

        method.AddLine(
            "var builder = app as IEndpointRouteBuilder ?? throw new ArgumentException(\"IApplicationBuilder is not an IEndpointRouteBuilder\");");

        foreach (var endpoint in endpoints)
        {
            method.AddLine($"builder.{endpoint.MappingEndpointMethodName}(app);");
        }

        method.AddLine("return app;");
    }

    private static List<string> BuildParameterList(EndpointDefinition endpoint, HashSet<string> usings)
    {
        return endpoint.EntryPoint.Parameters.Select(p =>
            {
                var attributesString = BuildParameterAttributes(p.Value, usings);
                var typeName = p.Value.Type.ToDisplayString(usings);
                var nullableSign = p.Value.Nullable && !typeName.EndsWith("?") ? "?" : "";
                return $"{attributesString}{typeName}{nullableSign} {p.Value.Name}";
            })
            .ToList();
    }

    public static string BuildParameterAttributes(ParameterInfo parameter, HashSet<string> usings)
    {
        var attributes = parameter.Attributes
            .Select(attr => attr.ToDisplayString(usings))
            .Where(attr => !string.IsNullOrEmpty(attr))
            .ToList();

        return attributes.Count > 0 ? string.Join(" ", attributes) + " " : "";
    }

    private static string GetLifetimeMethodName(ServiceLifetime lifetime) => lifetime switch
    {
        ServiceLifetime.Singleton => "AddSingleton",
        ServiceLifetime.Transient => "AddTransient",
        _ => "AddScoped"
    };
}

using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using MinimalEndpoints.Analyzers.Models;
using MinimalEndpoints.Analyzers.Utilities;

namespace MinimalEndpoints.Analyzers;

[Generator]
public class EndpointGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register a syntax provider that:
        // 1. Filters syntax nodes quickly (predicate) - runs on every keystroke
        // 2. Transforms matching nodes with semantic info (transform) - more expensive
        var endpointClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                // Predicate: Fast syntax-only check (no semantic model)
                predicate: static (syntaxNode, _) => syntaxNode is ClassDeclarationSyntax classDeclarationSyntax
                                                     && !classDeclarationSyntax.Modifiers.Any(SyntaxKind
                                                         .AbstractKeyword)
                                                     && classDeclarationSyntax.AttributeLists.Count > 0,
                // Transform: Slower semantic analysis with full type information
                transform: GetEndpointInfo)
            .Where(static info => info is not null); // Filter out nulls

        // Collect all endpoint infos and generate code when compilation changes
        context.RegisterSourceOutput(
            endpointClasses.Collect(),
            static (sourceContext, endpointInfos) => { GenerateEndpointExtensions(sourceContext, endpointInfos!); });
    }

    /// <summary>
    /// Analyzes a class declaration to determine if it's an endpoint and extract metadata.
    /// </summary>
    private static EndpointInfo GetEndpointInfo(
        GeneratorSyntaxContext context,
        CancellationToken cancellationToken)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;

        // Get the semantic model symbol for this class
        var classSymbol = ModelExtensions.GetDeclaredSymbol(context.SemanticModel, classDecl, cancellationToken);
        if (classSymbol is not INamedTypeSymbol namedTypeSymbol)
        {
            return null;
        }

        var mapMethodsAttributeInfo = namedTypeSymbol.GetMapMethodsAttributeInfo();

        if (mapMethodsAttributeInfo == null)
        {
            return null;
        }

        var entryPoint = namedTypeSymbol.FindEntryPointMethod(mapMethodsAttributeInfo.EntryPoint);

        return entryPoint == null
            ? null
            : EndpointInfo.Create(namedTypeSymbol, entryPoint, mapMethodsAttributeInfo);
    }

    /// <summary>
    /// Generates the extension methods file for all discovered endpoints.
    /// </summary>
    private static void GenerateEndpointExtensions(
        SourceProductionContext context,
        ImmutableArray<EndpointInfo> endpoints)
    {
        if (endpoints.IsEmpty)
        {
            return;
        }

        var sb = new StringBuilder();

        // File header
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// This file is generated by MinimalEndpoints.SourceGenerator");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using Microsoft.AspNetCore.Builder;");
        sb.AppendLine("using Microsoft.AspNetCore.Http;");
        sb.AppendLine("using Microsoft.AspNetCore.Routing;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Microsoft.AspNetCore.Mvc;");
        sb.AppendLine("using MinimalEndpoints;");
        sb.AppendLine();

        // Add namespaces for endpoint types
        var namespaces = endpoints.Select(e => e.Namespace).Distinct();
        foreach (var ns in namespaces)
        {
            sb.AppendLine($"using {ns};");
        }

        sb.AppendLine();

        // Generate extension class
        sb.AppendLine("namespace MinimalEndpoints.Generated;");
        sb.AppendLine();
        sb.AppendLine("public static class MinimalEndpointExtensions");
        sb.AppendLine("{");

        GenerateEndpointRegistrations(sb, endpoints);

        foreach (var endpoint in endpoints)
        {
            GenerateMapMethod(sb, endpoint);
        }

        GenerateRouteBuilder(sb, endpoints);

        sb.AppendLine("}");

        // Add the generated source to the compilation
        context.AddSource("MinimalEndpointExtensions.g.cs", sb.ToString());
    }

    private static void GenerateEndpointRegistrations(StringBuilder sb, ImmutableArray<EndpointInfo> endpoints)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Registers all discovered endpoints service collection.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine(
            "    public static IServiceCollection AddMinimalEndpoints(this IServiceCollection services)");
        sb.AppendLine("    {");

        foreach (var endpoint in endpoints)
        {
            var lifetime = endpoint.MapMethodsAttribute.Lifetime switch
            {
                ServiceLifetime.Singleton => "AddSingleton",
                ServiceLifetime.Scoped => "AddScoped",
                ServiceLifetime.Transient => "AddTransient",
                _ => "AddScoped"
            };

            sb.AppendLine(
                endpoint.MapMethodsAttribute.ServiceName != null
                    ? $"        services.{lifetime}<{endpoint.MapMethodsAttribute.ServiceName}, {endpoint.FullTypeName}>();"
                    : $"        services.{lifetime}<{endpoint.FullTypeName}>();");
        }

        sb.AppendLine("        return services;");
        sb.AppendLine("    }");
    }

    /// <summary>
    /// Generates a Map{EndpointName} extension method for a single endpoint.
    /// </summary>
    private static void GenerateMapMethod(StringBuilder sb, EndpointInfo endpoint)
    {
        sb.AppendLine($"    /// <summary>");
        sb.AppendLine($"    /// Maps {endpoint.ClassName} to the endpoint route builder.");
        sb.AppendLine($"    /// </summary>");
        sb.AppendLine(
            $"    public static IEndpointRouteBuilder {endpoint.MappingEndpointMethodName}(this IEndpointRouteBuilder builder, IApplicationBuilder app)");
        sb.AppendLine("    {");

        GenerateHandlerDelegate(sb, endpoint);

        sb.AppendLine("        return builder;");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates the handler delegate and mapping logic for a specific method.
    /// </summary>
    private static void GenerateHandlerDelegate(
        StringBuilder sb,
        EndpointInfo endpoint
    )
    {
        // Build parameter list for the lambda
        var paramList = endpoint.EntryPoint.Parameters.Select(p =>
            {
                var attributes = p.Attributes
                    .Select(x =>
                    {
                        var attrName = x.AttributeClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        if (attrName == null)
                        {
                            return string.Empty;
                        }

                        // Handle attribute names with or without "Attribute" suffix
                        if (attrName.EndsWith("Attribute"))
                        {
                            attrName = attrName.Substring(0, attrName.Length - "Attribute".Length);
                        }

                        return $"[{attrName}]";
                    })
                    .ToList();


                var attrString = attributes.Count > 0 ? string.Join(" ", attributes) + " " : "";
                var nullableSign = p.Nullable && !p.Type.EndsWith("?") ? "?" : "";
                return $"{attrString}{p.Type}{nullableSign} {p.Name}";
            })
            .ToList();

        var serviceName = endpoint.MapMethodsAttribute.ServiceName ?? endpoint.FullTypeName;
        paramList.Insert(0, $"[global::Microsoft.AspNetCore.Mvc.FromServices] {serviceName} endpointInstance");

        // Generate the handler delegate
        sb.AppendLine($"        static {endpoint.EntryPoint.ReturnType} Handler({string.Join(", ", paramList)})");
        sb.AppendLine("        {");

        // Call the handle method
        var methodArgs = endpoint.EntryPoint.Parameters.Count > 0
            ? string.Join(", ", endpoint.EntryPoint.Parameters.Select(p => p.Name))
            : "";

        sb.AppendLine($"            return endpointInstance.{endpoint.EntryPoint.Name}({methodArgs});");
        sb.AppendLine("        };");
        sb.AppendLine();

        var pattern = endpoint.MapMethodsAttribute.Pattern;
        if (endpoint.MapMethodsAttribute.Methods.Length > 1)
        {
            var methods = string.Join(", ",
                endpoint.MapMethodsAttribute.Methods.Select(m => $"\"{m.ToUpperInvariant()}\""));
            sb.AppendLine($"        var endpoint = builder.MapMethods(\"{pattern}\", [{methods}], Handler);");
        }
        else
        {
            sb.AppendLine(
                $"        var endpoint = builder.{endpoint.MapMethodsAttribute.EndpointBuilderMethodName}(\"{pattern}\", Handler);");
        }

        // Apply IConfigurableEndpoint configuration
        if (endpoint.IsConfigurable)
        {
            sb.AppendLine($"        {endpoint.FullTypeName}.Configure(app, endpoint);");
        }
    }

    /// <summary>
    /// Generates a convenience method to map all endpoints at once.
    /// </summary>
    private static void GenerateRouteBuilder(StringBuilder sb, ImmutableArray<EndpointInfo> endpoints)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Maps all discovered endpoints to the endpoint route builder.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine(
            "    public static IApplicationBuilder UseMinimalEndpoints(this IApplicationBuilder app)");
        sb.AppendLine("    {");

        sb.AppendLine(
            "        var builder = app as IEndpointRouteBuilder ?? throw new ArgumentException(\"IApplicationBuilder is not an IEndpointRouteBuilder\");");

        foreach (var endpoint in endpoints)
        {
            sb.AppendLine($"        builder.{endpoint.MappingEndpointMethodName}(app);");
        }

        sb.AppendLine("        return app;");
        sb.AppendLine("    }");
    }
}

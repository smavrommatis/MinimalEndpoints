using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using MinimalEndpoints.CodeGeneration.Endpoints.Models;
using MinimalEndpoints.CodeGeneration.Groups.Models;
using MinimalEndpoints.CodeGeneration.Models;

namespace MinimalEndpoints.CodeGeneration;

internal static class MinimalEndpointsFileBuilder
{
    public static CSharpFileScope GenerateFile(
        string namespaceName,
        string className,
        List<EndpointDefinition> endpoints,
        Dictionary<INamedTypeSymbol, EndpointGroupDefinition> groups
    )
    {
        if (!endpoints.Any() && !groups.Any())
        {
            return null;
        }

        var fileScope = CreateFileScope(namespaceName, className);

        fileScope.AddMinimalEndpointsRegistrationMethod(endpoints, [..groups.Values]);

        // Add group mapping methods
        foreach (var group in groups.Values)
        {
            fileScope.AddGroupMapMethod(group);
        }

        foreach (var endpoint in endpoints)
        {
            fileScope.AddMinimalEndpointMapMethod(endpoint, groups);
        }

        fileScope.AddMinimalEndpointsMapAllMethods(endpoints, groups);

        return fileScope;
    }

    public static CSharpFileScope CreateFileScope(string namespaceName, string className)
    {
        return new CSharpFileScope("public static", namespaceName, className)
            .WithHeader("""
                        //----------------------
                        // <auto-generated>
                        //     This file was generated by MinimalEndpoints.CodeGeneration.EndpointGenerator.
                        //     Do not edit this file manually.
                        // </auto-generated>
                        //----------------------
                        #nullable enable
                        """
            )
            .AddUsing("System")
            .AddUsing("System.Threading")
            .AddUsing("System.Threading.Tasks")
            .AddUsing("System.Collections.Generic")
            .AddUsing("System.CodeDom.Compiler")
            .AddUsing("Microsoft.AspNetCore.Builder")
            .AddUsing("Microsoft.AspNetCore.Routing")
            .AddUsing("Microsoft.AspNetCore.Http")
            .AddUsing("Microsoft.Extensions.DependencyInjection")
            .AddUsing("Microsoft.AspNetCore.Mvc")
            .AddUsing("MinimalEndpoints")
            .AddClassAttribute("[GeneratedCode(\"MinimalEndpoints.CodeGeneration.EndpointGenerator\", \"1.0.0\")]");
    }

    private static CSharpFileScope AddMinimalEndpointsRegistrationMethod(
        this CSharpFileScope fileScope,
        List<EndpointDefinition> endpoints,
        ImmutableArray<EndpointGroupDefinition> groupDefinitions
    )
    {
        if (endpoints.Count == 0 && groupDefinitions.Length == 0)
        {
            return fileScope;
        }

        var method = fileScope.AddMethod(
            modifiers: "public static",
            returnType: "IServiceCollection",
            methodName: "AddMinimalEndpoints",
            parameters: "this IServiceCollection services"
        );

        var usings = fileScope.GetAvailableUsings();

        // Register groups first (as singletons since they're typically stateless)
        foreach (var group in groupDefinitions)
        {
            method.AddLine($"services.AddSingleton<{group.ClassType.ToDisplayString(usings)}>();");
        }

        if (groupDefinitions.Any())
        {
            method.AddEmptyLine();
        }

        // Register endpoints
        foreach (var endpoint in endpoints)
        {
            var lifetime = GetLifetimeMethodName(endpoint.MapMethodsAttribute.Lifetime);
            var classTypeName = endpoint.ClassType.ToDisplayString(usings);

            var registrationLine = endpoint.MapMethodsAttribute.ServiceName != null
                ? $"services.{lifetime}<{endpoint.MapMethodsAttribute.ServiceName}, {classTypeName}>();"
                : $"services.{lifetime}<{classTypeName}>();";

            method.AddLine(registrationLine);
        }

        method.AddLine("return services;");

        return fileScope;
    }

    private static CSharpFileScope AddGroupMapMethod(this CSharpFileScope fileScope,
        EndpointGroupDefinition groupDefinition)
    {
        var usings = fileScope.GetAvailableUsings();

        // Determine parameters: if it has parent, need parent group parameter
        var parameters = groupDefinition.ParentGroup != null
            ? "this IEndpointRouteBuilder builder, IApplicationBuilder app, RouteGroupBuilder parentGroup"
            : "this IEndpointRouteBuilder builder, IApplicationBuilder app";

        var method = fileScope.AddMethod(
            modifiers: "public static",
            returnType: groupDefinition.IsConditionallyMapped ? "RouteGroupBuilder?" : "RouteGroupBuilder",
            methodName: groupDefinition.MappingGroupMethodName,
            parameters: parameters
        );

        if (groupDefinition.IsConditionallyMapped)
        {
            method.AddLine($"if (!{groupDefinition.ClassType.FullName}.ShouldMap(app))");
            method.AddLine("{");
            method.AddLine("return null;", additionalIndentation: 1);
            method.AddLine("}");
            method.AddEmptyLine();
        }

        // Map to parent group or main builder
        var builderExpression = groupDefinition.ParentGroup != null ? "parentGroup" : "builder";

        method.AddLine($"var group = {builderExpression}.MapGroup(\"{groupDefinition.Prefix}\");");

        if (groupDefinition.IsConfigurable)
        {
            method.AddLine(
                $"var groupInstance = app.ApplicationServices.GetRequiredService<{groupDefinition.ClassType.FullName}>();");
            method.AddLine($"groupInstance.ConfigureGroup(group);");
        }

        method.AddLine($"return group;");

        return fileScope;
    }

    private static CSharpFileScope AddMinimalEndpointMapMethod(
        this CSharpFileScope fileScope,
        EndpointDefinition endpoint,
        Dictionary<INamedTypeSymbol, EndpointGroupDefinition> allGroups
    )
    {
        const string instanceParameterBaseName = "endpointInstance";

        var hasGroup = endpoint.MapMethodsAttribute.GroupType != null
                       && allGroups.ContainsKey(endpoint.MapMethodsAttribute.GroupType);
        // Determine parameters: if endpoint has a group, include it
        var methodParameters = hasGroup
            ? "this IEndpointRouteBuilder builder, IApplicationBuilder app, RouteGroupBuilder group"
            : "this IEndpointRouteBuilder builder, IApplicationBuilder app";

        var method = fileScope.AddMethod(
            modifiers: "public static",
            returnType: endpoint.IsConditionallyMapped ? "IEndpointRouteBuilder?" : "IEndpointRouteBuilder",
            methodName: endpoint.MappingEndpointMethodName,
            parameters: methodParameters
        );

        var usings = fileScope.GetAvailableUsings();
        var classTypeName = endpoint.ClassType.ToDisplayString(usings);
        var serviceName = endpoint.MapMethodsAttribute.ServiceName ?? classTypeName;
        var parameterList = BuildParameterList(endpoint, usings);
        var methodArguments = endpoint.EntryPoint.Parameters.Count > 0
            ? string.Join(", ", endpoint.EntryPoint.Parameters.Select(p => p.Key))
            : "";

        var instanceParameterName = "endpointInstance";
        var index = 0;

        while (endpoint.EntryPoint.Parameters.ContainsKey(instanceParameterName))
        {
            instanceParameterName = GetUniqueIndexedName(instanceParameterBaseName, ++index);
        }

        parameterList.Insert(0, $"[FromServices]{serviceName} {instanceParameterName}");

        var returnTypeName = endpoint.EntryPoint.ReturnType.ToDisplayString(usings);

        if (endpoint.IsConditionallyMapped)
        {
            method.AddLine($"if (!{classTypeName}.ShouldMap(app))");
            method.AddLine("{");
            method.AddLine("return null;", additionalIndentation: 1);
            method.AddLine("}");
            method.AddEmptyLine();
        }

        method.AddLine(
            $"static {returnTypeName} Handler({string.Join(", ", parameterList)})"
        );
        method.AddLine("{");
        method.AddLine($"return {instanceParameterName}.{endpoint.EntryPoint.Name}({methodArguments});",
            additionalIndentation: 1);
        method.AddLine("}");

        method.AddEmptyLine();

        var pattern = endpoint.MapMethodsAttribute.Pattern;

        // Determine the builder to use (group parameter or main builder)
        var builderExpression = hasGroup ? "group" : "builder";

        if (endpoint.MapMethodsAttribute.Methods.Length > 1)
        {
            var methods = string.Join(", ",
                endpoint.MapMethodsAttribute.Methods.Select(m => $"\"{m.ToUpperInvariant()}\""));
            method.AddLine(
                $"var endpoint = {builderExpression}.MapMethods(\"{pattern}\", [{methods}], Handler);");
        }
        else
        {
            method.AddLine(
                $"var endpoint = {builderExpression}.{endpoint.MapMethodsAttribute.EndpointBuilderMethodName}(\"{pattern}\", Handler);");
        }

        if (endpoint.IsConfigurable)
        {
            method.AddLine($"{classTypeName}.Configure(app, endpoint);");
        }

        method.AddLine("return builder;");

        return fileScope;
    }

    private static string GetUniqueIndexedName(string name, int index)
    {
        return index <= 0 ? name : $"{name}{index}";
    }

    private static void AddMinimalEndpointsMapAllMethods(this CSharpFileScope fileScope,
        List<EndpointDefinition> endpoints,
        Dictionary<INamedTypeSymbol, EndpointGroupDefinition> groups
    )
    {
        var method = fileScope.AddMethod(
            modifiers: "public static",
            returnType: "IApplicationBuilder",
            methodName: "UseMinimalEndpoints",
            parameters: "this IApplicationBuilder app"
        );

        method.AddLine(
            "var builder = app as IEndpointRouteBuilder ?? throw new ArgumentException(\"IApplicationBuilder is not an IEndpointRouteBuilder\");");

        if (groups.Count > 0)
        {
            method.AddEmptyLine();
            method.AddLine("// Create and configure groups in hierarchy order");

            // Sort groups by hierarchy: parents before children
            var sortedGroups = groups.Values.OrderBy(x => x.Depth);

            foreach (var group in sortedGroups)
            {
                if (group.ParentGroup is not null)
                {
                    method.AddLine(group.HierarchyConditionallyMapped
                        ? $"var {group.VariableName} = {group.ParentGroup.VariableName} is null ? null : builder.{group.MappingGroupMethodName}(app, {group.ParentGroup.VariableName});"
                        : $"var {group.VariableName} = builder.{group.MappingGroupMethodName}(app, {group.ParentGroup.VariableName});");
                }
                else
                {
                    method.AddLine($"var {group.VariableName} = builder.{group.MappingGroupMethodName}(app);");
                }
            }

            method.AddEmptyLine();
        }

        method.AddLine("// Map endpoints");

        var (endpointsWithoutGroups, endpointsWithGroups) = GroupEndpointsByGroup(endpoints);

        foreach (var endpoint in endpointsWithoutGroups)
        {
            method.AddLine($"builder.{endpoint.MappingEndpointMethodName}(app);");
        }

        foreach (var pair in endpointsWithGroups)
        {
            var symbol = pair.Key;

            if (groups.TryGetValue(symbol, out var group))
            {
                var indentationLevel = 0;
                if (group.HierarchyConditionallyMapped)
                {
                    method.AddLine($"if ({group.VariableName} is not null)");
                    method.AddLine("{");
                    indentationLevel = 1;
                }

                foreach (var endpoint in pair.Value)
                {
                    var mapEndpointLine = $"builder.{endpoint.MappingEndpointMethodName}(app, {group.VariableName});";
                    method.AddLine(mapEndpointLine, indentationLevel);
                }

                if (group.HierarchyConditionallyMapped)
                {
                    method.AddLine("}");
                }
            }
            else
            {
                foreach (var endpoint in pair.Value)
                {
                    method.AddLine($"builder.{endpoint.MappingEndpointMethodName}(app);");
                }
            }
        }

        method.AddLine("return app;");
    }

    private static (List<EndpointDefinition> endpointsWithoutGroups, Dictionary<INamedTypeSymbol, List<EndpointDefinition>> endpointsWithGroups) GroupEndpointsByGroup(List<EndpointDefinition> endpoints)
    {
        var endpointsWithoutGroups = new List<EndpointDefinition>();
        var endpointsWithGroups = new Dictionary<INamedTypeSymbol, List<EndpointDefinition>>(SymbolEqualityComparer.Default);

        foreach (var endpoint in endpoints)
        {
            if (endpoint.MapMethodsAttribute.GroupType == null)
            {
                endpointsWithoutGroups.Add(endpoint);
            }
            else
            {
                if (!endpointsWithGroups.TryGetValue(endpoint.MapMethodsAttribute.GroupType, out var list))
                {
                    endpointsWithGroups[endpoint.MapMethodsAttribute.GroupType] = list = [];
                }

                list.Add(endpoint);
            }
        }

        return (endpointsWithoutGroups, endpointsWithGroups);
    }

    private static List<string> BuildParameterList(EndpointDefinition endpoint, HashSet<string> usings)
    {
        return endpoint.EntryPoint.Parameters.Select(p =>
            {
                var attributesString = BuildParameterAttributes(p.Value, usings);
                var typeName = p.Value.Type.ToDisplayString(usings);
                var nullableSign = p.Value.Nullable && !typeName.EndsWith("?") ? "?" : "";
                return $"{attributesString}{typeName}{nullableSign} {p.Value.Name}";
            })
            .ToList();
    }

    public static string BuildParameterAttributes(ParameterInfo parameter, HashSet<string> usings)
    {
        if (parameter.Attributes.Count == 0)
        {
            return string.Empty;
        }

        var sb = new StringBuilder();
        foreach (var attr in parameter.Attributes)
        {
            var attrString = attr.ToDisplayString(usings);
            if (!string.IsNullOrEmpty(attrString))
            {
                if (sb.Length > 0)
                {
                    sb.Append(' ');
                }

                sb.Append(attrString);
            }
        }

        return sb.Length > 0 ? sb.Append(' ').ToString() : string.Empty;
    }

    private static string GetLifetimeMethodName(ServiceLifetime lifetime) => lifetime switch
    {
        ServiceLifetime.Singleton => "AddSingleton",
        ServiceLifetime.Transient => "AddTransient",
        _ => "AddScoped"
    };
}

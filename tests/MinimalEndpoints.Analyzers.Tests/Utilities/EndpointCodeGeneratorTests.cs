using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using MinimalEndpoints.Analyzers.Models;
using MinimalEndpoints.Analyzers.Utilities;

namespace MinimalEndpoints.Analyzers.Tests.Utilities;

public class EndpointCodeGeneratorTests
{
    [Fact]
    public void GenerateCode_WithEmptyEndpoints_ReturnsNull()
    {
        // Arrange
        var endpoints = ImmutableArray<EndpointDefinition>.Empty;

        // Act
        var result = EndpointCodeGenerator.GenerateCode("TestNamespace", "TestClass", endpoints);

        // Assert
        Assert.Null(result);
    }

    [Fact]
    public void CreateFileScope_AddsRequiredUsings()
    {
        // Act
        var fileScope = EndpointCodeGenerator.CreateFileScope("TestNamespace", "TestClass");
        var usings = fileScope.GetAvailableUsings();

        // Assert
        Assert.Contains("System", usings);
        Assert.Contains("System.Threading.Tasks", usings);
        Assert.Contains("Microsoft.AspNetCore.Builder", usings);
        Assert.Contains("Microsoft.AspNetCore.Http", usings);
        Assert.Contains("Microsoft.Extensions.DependencyInjection", usings);
        Assert.Contains("MinimalEndpoints", usings);
    }

    [Fact]
    public void CreateFileScope_AddsGeneratedCodeAttribute()
    {
        // Act
        var fileScope = EndpointCodeGenerator.CreateFileScope("TestNamespace", "TestClass");
        var code = fileScope.Build();

        // Assert
        Assert.Contains("[GeneratedCode(\"MinimalEndpoints.Analyzers.EndpointGenerator\", \"1.0.0\")]", code);
    }

    [Fact]
    public void CreateFileScope_AddsAutoGeneratedHeader()
    {
        // Act
        var fileScope = EndpointCodeGenerator.CreateFileScope("TestNamespace", "TestClass");
        var code = fileScope.Build();

        // Assert
        Assert.Contains("<auto-generated>", code);
        Assert.Contains("Do not edit this file manually", code);
    }

    [Fact]
    public void BuildParameterAttributes_WithNoAttributes_ReturnsEmptyString()
    {
        // Arrange
        var code = @"
public class TestClass
{
    public void Method(string parameter) { }
}";
        var compilation = new CompilationBuilder(code).Build();
        var type = compilation.GetTypeByMetadataName("TestClass");
        var method = type!.GetMembers("Method").OfType<IMethodSymbol>().First();
        var param = method.Parameters[0];

        var parameter = new ParameterInfo
        {
            Name = param.Name,
            Type = new TypeDefinition(param.Type),
            Attributes = []
        };
        var usings = new HashSet<string>();

        // Act
        var result = EndpointCodeGenerator.BuildParameterAttributes(parameter, usings);

        // Assert
        Assert.Empty(result);
    }

    [Fact]
    public void BuildParameterAttributes_WithMultipleAttributes_ConcatenatesWithSpace()
    {
        // Arrange
        var code = @"
using Microsoft.AspNetCore.Mvc;
using System.ComponentModel.DataAnnotations;

public class TestClass
{
    public void Method([FromBody][Required] string parameter) { }
}";
        var compilation = new CompilationBuilder(code)
            .WithMvcReferences()
            .Build();

        var type = compilation.GetTypeByMetadataName("TestClass");
        var method = type!.GetMembers("Method").OfType<IMethodSymbol>().First();
        var param = method.Parameters[0];

        var parameter = new ParameterInfo
        {
            Name = param.Name,
            Type = new TypeDefinition(param.Type),
            Attributes = param.GetAttributes()
                .Select(AttributeDefinition.FromAttributeData)
                .Where(a => a != null)
                .ToList()
        };

        var usings = new HashSet<string> { "Microsoft.AspNetCore.Mvc", "System.ComponentModel.DataAnnotations" };

        // Act
        var result = EndpointCodeGenerator.BuildParameterAttributes(parameter, usings);

        // Assert
        Assert.Contains("[FromBody]", result);
        Assert.Contains("[Required]", result);
        Assert.EndsWith(" ", result); // Should end with space for concatenation
    }

    [Fact]
    public void GetLifetimeMethodName_ReturnsCorrectMethod_ForAllLifetimes()
    {
        // This is a private method, but we can test it indirectly through registration

        // Test through public API
        var code =
            @"
            using MinimalEndpoints.Annotations;
            using Microsoft.Extensions.DependencyInjection;

            [MapGet(""/singleton"", ServiceLifetime.Singleton)]
            public class SingletonEndpoint { public void Handle() { } }

            [MapGet(""/scoped"", ServiceLifetime.Scoped)]
            public class ScopedEndpoint { public void Handle() { } }

            [MapGet(""/transient"", ServiceLifetime.Transient)]
            public class TransientEndpoint { public void Handle() { } }
            ";

        var compilation = new CompilationBuilder(code)
            .WithMvcReferences()
            .Build();

        var singletonSymbol = compilation.GetTypeByMetadataName("SingletonEndpoint");
        var scopedSymbol = compilation.GetTypeByMetadataName("ScopedEndpoint");
        var transientSymbol = compilation.GetTypeByMetadataName("TransientEndpoint");

        var singletonAttr = singletonSymbol!.GetMapMethodAttributeDefinition();
        var scopedAttr = scopedSymbol!.GetMapMethodAttributeDefinition();
        var transientAttr = transientSymbol!.GetMapMethodAttributeDefinition();

        // Verify through attribute definitions
        Assert.Equal(ServiceLifetime.Singleton, singletonAttr.Lifetime);
        Assert.Equal(ServiceLifetime.Scoped, scopedAttr.Lifetime);
        Assert.Equal(ServiceLifetime.Transient, transientAttr.Lifetime);
    }
}


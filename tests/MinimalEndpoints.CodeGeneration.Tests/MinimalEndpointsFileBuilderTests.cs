using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using MinimalEndpoints.CodeGeneration.Endpoints;
using MinimalEndpoints.CodeGeneration.Endpoints.Models;
using MinimalEndpoints.CodeGeneration.Groups.Models;
using MinimalEndpoints.CodeGeneration.Models;
using MinimalEndpoints.CodeGeneration.Utilities;

namespace MinimalEndpoints.CodeGeneration.Tests;

public class MinimalEndpointsFileBuilderTests
{
    [Fact]
    public void GenerateCode_WithEmptyEndpoints_ReturnsNull()
    {
        // Arrange
        var endpoints = new List<EndpointDefinition>();
        var groups = new Dictionary<INamedTypeSymbol, EndpointGroupDefinition>(SymbolEqualityComparer.Default);

        // Act
        var result = MinimalEndpointsFileBuilder.GenerateFile("TestNamespace", "TestClass", endpoints, groups);

        // Assert
        Assert.Null(result);
    }

    [Fact]
    public void CreateFileScope_AddsRequiredUsings()
    {
        // Act
        var fileScope = MinimalEndpointsFileBuilder.CreateFileScope("TestNamespace", "TestClass");
        var usings = fileScope.GetAvailableUsings();

        // Assert
        Assert.Contains("System", usings);
        Assert.Contains("System.Threading.Tasks", usings);
        Assert.Contains("Microsoft.AspNetCore.Builder", usings);
        Assert.Contains("Microsoft.AspNetCore.Http", usings);
        Assert.Contains("Microsoft.Extensions.DependencyInjection", usings);
        Assert.Contains("MinimalEndpoints", usings);
    }

    [Fact]
    public void CreateFileScope_AddsGeneratedCodeAttribute()
    {
        // Act
        var fileScope = MinimalEndpointsFileBuilder.CreateFileScope("TestNamespace", "TestClass");
        var code = fileScope.Build();

        // Assert
        Assert.Contains("[GeneratedCode(\"MinimalEndpoints.CodeGeneration.EndpointGenerator\", \"1.0.0\")]", code);
    }

    [Fact]
    public void CreateFileScope_AddsAutoGeneratedHeader()
    {
        // Act
        var fileScope = MinimalEndpointsFileBuilder.CreateFileScope("TestNamespace", "TestClass");
        var code = fileScope.Build();

        // Assert
        Assert.Contains("<auto-generated>", code);
        Assert.Contains("Do not edit this file manually", code);
    }

    [Fact]
    public void BuildParameterAttributes_WithNoAttributes_ReturnsEmptyString()
    {
        // Arrange
        var code = @"
public class TestClass
{
    public void Method(string parameter) { }
}";
        var compilation = new CompilationBuilder(code).Build();
        var type = compilation.GetTypeByMetadataName("TestClass");
        var method = type!.GetMembers("Method").OfType<IMethodSymbol>().First();
        var param = method.Parameters[0];

        var parameter = new ParameterInfo
        {
            Name = param.Name,
            Type = new TypeDefinition(param.Type),
            Attributes = []
        };
        var usings = new HashSet<string>();

        // Act
        var result = MinimalEndpointsFileBuilder.BuildParameterAttributes(parameter, usings);

        // Assert
        Assert.Empty(result);
    }

    [Fact]
    public void BuildParameterAttributes_WithMultipleAttributes_ConcatenatesWithSpace()
    {
        // Arrange
        var code = @"
using Microsoft.AspNetCore.Mvc;
using System.ComponentModel.DataAnnotations;

public class TestClass
{
    public void Method([FromBody][Required] string parameter) { }
}";
        var compilation = new CompilationBuilder(code)
            .WithMvcReferences()
            .Build();

        var type = compilation.GetTypeByMetadataName("TestClass");
        var method = type!.GetMembers("Method").OfType<IMethodSymbol>().First();
        var param = method.Parameters[0];

        var parameter = new ParameterInfo
        {
            Name = param.Name,
            Type = new TypeDefinition(param.Type),
            Attributes = param.GetAttributes()
                .Select(AttributeDefinition.FromAttributeData)
                .Where(a => a != null)
                .ToList()
        };

        var usings = new HashSet<string> { "Microsoft.AspNetCore.Mvc", "System.ComponentModel.DataAnnotations" };

        // Act
        var result = MinimalEndpointsFileBuilder.BuildParameterAttributes(parameter, usings);

        // Assert
        Assert.Contains("[FromBody]", result);
        Assert.Contains("[Required]", result);
        Assert.EndsWith(" ", result); // Should end with space for concatenation
    }

    [Fact]
    public void GetLifetimeMethodName_ReturnsCorrectMethod_ForAllLifetimes()
    {
        // This is a private method, but we can test it indirectly through registration

        // Test through public API
        var code =
            @"
            using MinimalEndpoints.Annotations;
            using Microsoft.Extensions.DependencyInjection;

            [MapGet(""/singleton"", ServiceLifetime.Singleton)]
            public class SingletonEndpoint { public void Handle() { } }

            [MapGet(""/scoped"", ServiceLifetime.Scoped)]
            public class ScopedEndpoint { public void Handle() { } }

            [MapGet(""/transient"", ServiceLifetime.Transient)]
            public class TransientEndpoint { public void Handle() { } }
            ";

        var compilation = new CompilationBuilder(code)
            .WithMvcReferences()
            .Build();

        var singletonSymbol = compilation.GetTypeByMetadataName("SingletonEndpoint");
        var scopedSymbol = compilation.GetTypeByMetadataName("ScopedEndpoint");
        var transientSymbol = compilation.GetTypeByMetadataName("TransientEndpoint");

        var singletonAttr = GetEndpointDefinition(singletonSymbol!)!.MapMethodsAttribute;
        var scopedAttr = GetEndpointDefinition(scopedSymbol!)!.MapMethodsAttribute;
        var transientAttr = GetEndpointDefinition(transientSymbol!)!.MapMethodsAttribute;

        // Verify through attribute definitions
        Assert.Equal(ServiceLifetime.Singleton, singletonAttr.Lifetime);
        Assert.Equal(ServiceLifetime.Scoped, scopedAttr.Lifetime);
        Assert.Equal(ServiceLifetime.Transient, transientAttr.Lifetime);
    }

    private static EndpointDefinition? GetEndpointDefinition(INamedTypeSymbol symbol) =>
        symbol.GetAttributes()
            .Where(EndpointDefinition.Factory.Predicate)
            .Select(x => EndpointDefinition.Factory.Create(symbol, x))
            .OfType<EndpointDefinition>()
            .SingleOrDefault();
}

